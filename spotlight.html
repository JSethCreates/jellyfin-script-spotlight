<!DOCTYPE html>
<html>
<head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
	<link href="https://fonts.googleapis.com/css2?family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&display=swap">
	
    <title>Seth's Spotlight - A Jellyfin UI Enhancement v5.4</title>
	<script>
    document.addEventListener('DOMContentLoaded', () => {
      const parentStyles = getComputedStyle(window.parent.document.documentElement);
      const root = document.documentElement;
      [
        '--md-sys-color-primary',
		'--md-sys-color-primary-container',
		'--md-sys-color-on-primary',
		'--md-sys-color-on-primary-container',
		'--md-sys-color-outline',
		'--color-text-body'
      ].forEach(name => {
        const val = parentStyles.getPropertyValue(name).trim();
        if (val) root.style.setProperty(name, val);
      });
    });
   </script>
	
    <style>
        body { margin: 0; padding: 0; overflow: hidden; }
        #slides-container { position: relative; width: 100vw; height: 100vh; }
        .slide { position: absolute; width: 100%; height: 100%; opacity: 0; filter: blur(5px); transition: opacity 1.3s ease, filter 1.3s ease; }
        .slide.visible { opacity: 1; filter: blur(0px); }
        .backdrop { position: absolute; top: 0px; left: 0; width: 100%; height: calc(100% - 50px); object-fit: cover; object-position: center 25%; border-radius: 5px; z-index: 1; transition: width 0.3s ease; }
		.logo {
			position: absolute;
			top: 35%;
			left: 23%;
			transform: translateY(-50%) translateX(-50%) !important;
			max-height: 50%;
			max-width: 30%;
			width: auto;
			z-index: 5;
			text-shadow: -2px 2px 4px rgba(0, 0, 0, 0.5);
			filter: drop-shadow(1px 1px 1px);
			opacity: 1;
			transition: 
				transform 2.5s ease-in-out,
				opacity 2.5s ease-in-out;
		}
        .heading { 
            position: absolute; 
            bottom: 10px; /* Moved from top to bottom */
            left: 88%;
            transform: translateX(-50%);
            width: auto;
            background-color: rgba(0, 0, 0, 0.5); /* Added background for better visibility */
            padding: 10px 20px;
            border-radius: 5px;
            font-family: "Inter", sans-serif; 
            color: #D3D3D3; 
            font-size: 1.5em; 
            display: flex; 
            align-items: center; 
            justify-content: center; 
            z-index: 2; 
            box-sizing: border-box; 
        }
        .video-container { position: absolute; right: 0; bottom: 50px; width: 0; height: calc(100% - 50px); overflow: hidden; z-index: 0; transition: width 0.3s ease; }
        .video-player { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        .clickable-overlay { 
            position: absolute; 
            top: 0px; 
            left: 0; 
            width: calc(100% - 50px); 
            height: calc(100% - 50px); 
            z-index: 7; 
            cursor: pointer; 
            background: linear-gradient(140deg, rgba(0, 0, 0, 0.89) 0%, rgba(0, 0, 0, 0.69) 6.25%, rgba(0, 0, 0, 0.52) 12.5%, rgba(0, 0, 0, 0.39) 18.75%, rgba(0, 0, 0, 0.28) 25%, rgba(0, 0, 0, 0.2) 31.25%, rgba(0, 0, 0, 0.14) 37.5%, rgba(0, 0, 0, 0.09) 43.75%, rgba(0, 0, 0, 0.05) 50%, rgba(0, 0, 0, 0.03) 56.25%, rgba(0, 0, 0, 0.02) 62.5%, rgba(0, 0, 0, 0.01) 68.75%, rgba(0, 0, 0, 0) 75%, rgba(0, 0, 0, 0) 81.25%, rgba(0, 0, 0, 0) 87.5%, rgba(0, 0, 0, 0) 93.75%, rgba(0, 0, 0, 0) 100% ); 
            z-index: 10; 
        }
        .lorem-ipsum { position: absolute; top: 5vh; width: 100%; text-align: left; font-family: "Titillium Web", sans-serif; font-size: 1.5em; text-shadow: 3px 3px 20px rgba(0, 0, 0, 1); opacity: 1; transition: opacity 0.3s ease, width 0.3s ease; color: #ecf0f1; z-index: 11; box-sizing: border-box; line-height: 1.75em; padding-left: 4vw;}
        .plot {
		  position: absolute;
		  bottom: 1.1em;


		  color: var(--color-text-body);
		  font-family: "Inter", sans-serif;
		  font-size: clamp(0.65rem, 1.3vw, 1.6rem);
		  font-weight: 200;
		  font-variation-settings: "wght" 200;
		  font-style: italic;
		  line-height: 2em;

		  padding: 10px;
		  padding-top: 2.5em;
		  padding-bottom: 0em;
		  padding-left: 4vw;
		  padding-right: 2vw;

		  box-sizing: border-box;
		  z-index: 4;
		  transition: width 0.3s ease;
		  isolation: isolate;
		  white-space: nowrap;
		  overflow: hidden;
          text-overflow: ellipsis;
		  
		  width: 99.8vw;         /* Force full screen width - scrollbar */
		  min-width: 99.8vw;     /* Prevent it from shrinking below screen width */
		  display: block;  
		  
		  
		}
		.plot::before {
		  content: '';
		  position: absolute;
		  bottom: 1.25em;
		  left: -100vw;
		  width: 200vw;
		  height: 25px;
		  background: linear-gradient(
			to bottom,
			rgba(28, 27, 31, 0), 
			rgba(28, 27, 31, 1)
		  );
		  z-index: -1;
		}
        .slide:hover .logo {
			transform: translateY(-50%) translateX(-50%) scale(1.5) !important;
			opacity: 0.1 !important;
		}
        .slide:hover .lorem-ipsum { opacity: 1; }
        .star-icon { color: gold; font-size: 1em; margin-right: 0em; }
        .emby-scrollbuttons { 
            position: absolute; 
            bottom: 55px;
            left: 80%;
            transform: translateX(-50%);
            display: flex; 
            z-index: 2; 
            background-color: rgba(0, 0, 0, 0.5); /* Added background for better visibility */
            padding: 10px;
            border-radius: 5px;
        }
        .emby-scrollbuttons-button { 
            background: none; 
            border: none; 
            color: #b2008a; 
            font-size: 1.4em; 
            cursor: pointer; 
            padding: 6px; 
            margin: 0 5px;
        }
        .emby-scrollbuttons-button:disabled { 
            opacity: 0.5; 
            cursor: default; 
        }
        .material-icons { 
            font-family: 'Material Icons'; 
            font-weight: normal; 
            font-style: normal; 
            font-size: inherit; 
            display: inline-block; 
            line-height: 1; 
            text-transform: none; 
            letter-spacing: normal; 
            word-wrap: normal; 
            white-space: nowrap; 
            direction: ltr; 
            -webkit-font-smoothing: antialiased; 
            text-rendering: optimizeLegibility; 
            -moz-osx-font-smoothing: grayscale; 
            font-feature-settings: 'liga'; 
        }

        .error-message {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 0, 0, 0.8);
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
            font-family: "Titillium Web", sans-serif;
        }
		
		#navButtons button {
		  background-color: var(--md-sys-color-primary-container) !important;
		  color: var(--md-sys-color-on-primary-container) !important;
		  border-color: var(--md-sys-color-outline) !important;
		}
		
		#navButtons button:hover {
		  background-color: var(--md-sys-color-primary) !important;
		  color: var(--md-sys-color-on-primary) !important;
		  border-color: var(--md-sys-color-outline) !important;
		}

		#navButtons button .material-icons {
		  color: var(--md-sys-color-outline);
		  transition: color 0.2s ease;
		}

		#navButtons button:hover .material-icons {
		  color: var(--md-sys-color-on-primary);
		}

		#navButtons button:disabled {
		  opacity: 0.5;
		  cursor: default;
		}
		
		/* Shared hover state for both slide and info button */
		.spotlight-wrapper:hover .slide.visible .logo {
			transform: translateY(-50%) translateX(-50%) scale(1.5) !important;
			opacity: 0.1 !important;
		}
				
		
    </style>
    <script>
        // Global promise to handle YouTube Iframe API readiness
        let youTubeAPIReadyPromise = new Promise((resolve, reject) => {
            // Check if YT is already defined
            if (window.YT && window.YT.Player) {
                console.log("YouTube Iframe API already loaded.");
                resolve(window.YT);
            } else {
                // Define the callback for when the YouTube Iframe API is ready
                window.onYouTubeIframeAPIReady = function() {
                    console.log("YouTube Iframe API is ready.");
                    resolve(window.YT);
                };

                // Load YouTube Iframe API if not already loaded
                if (!document.querySelector('script[src="https://www.youtube.com/iframe_api"]')) {
                    const tag = document.createElement('script');
                    tag.src = "https://www.youtube.com/iframe_api";
                    const firstScriptTag = document.getElementsByTagName('script')[0];
                    firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
                    console.log("YouTube Iframe API script added.");
                } else {
                    console.log("YouTube Iframe API script already present.");
                }

                // Set a timeout to reject the promise if API doesn't load
                setTimeout(() => {
                    reject(new Error("YouTube Iframe API failed to load within expected time."));
                }, 10000); // 10 seconds timeout
            }
        });
    </script>
</head>
<body>
    <div class="spotlight-wrapper">
    <div id="slides-container"></div>
    
	<div id="navButtons" style="
		position: absolute;
		bottom: 3.9em;
		right: .7em;
		display: flex;
		z-index: 2;
		background: none;
		border-radius: 9999px;">

	<!-- Left (first child) -->
	  <button id="leftButton" type="button" disabled tabindex="0" aria-label="Previous Movie"
			  style="border: 2px solid var(--md-sys-color-outline); border-radius: 9999px 0 0 9999px;
					 padding: 0.15em 0.9em; margin: 0; font-family: 'Titillium Web', sans-serif;
					 font-size: 1.2em; cursor: pointer;">
		<span class="material-icons" aria-hidden="true">chevron_left</span>
	  </button>

	  <!-- Media Info -->
	  <button id="mediaButton" type="button" tabindex="0" aria-label="View Media Info"
			  style="border: 2px solid var(--md-sys-color-outline); border-left: none;
					 border-radius: 0; padding: 0.15em 0.9em; margin: 0;
					 font-family: 'Titillium Web', sans-serif; font-size: 1.2em;
					 cursor: pointer;">
		<span class="material-icons" aria-hidden="true">info</span>
	  </button>

	  <!-- Play/Pause (hidden initially) -->
	  <button id="playPauseButton" type="button" tabindex="0" aria-label="Toggle Trailer Playback"
			  style="display: none; border: 2px solid var(--md-sys-color-outline); border-left: none;
					 border-radius: 0; padding: 0.15em 0.9em; margin: 0;
					 font-family: 'Titillium Web', sans-serif; font-size: 1.2em;
					 cursor: pointer;">
		<span class="material-icons" aria-hidden="true">play_arrow</span>
	  </button>

	  <!-- Right (last child) -->
	  <button id="rightButton" type="button" tabindex="0" aria-label="Next Movie"
			  style="border: 2px solid var(--md-sys-color-outline); border-left: none;
					 border-radius: 0 9999px 9999px 0; padding: 0.15em 0.9em; margin: 0;
					 font-family: 'Titillium Web', sans-serif; font-size: 1.2em;
					 cursor: pointer;">
		<span class="material-icons" aria-hidden="true">chevron_right</span>
  </button>
</div>
		
    <script>
        // Initialize global variables
        let customTitle = '';
        let moviesSeriesBoth = 3, shuffleInterval = 10000, plotMaxLength = 250, token = 'de81a85d55024d7b9fa7b11031de7539', useTrailers = true;
        let isChangingSlide = false, player = null, slideChangeTimeout = null, isHomePageActive = false, navigationInterval = null;
        let currentLocation = window.top.location.href;
        let movieList = [], currentMovieIndex = 0, lastMovie = null, currentMovie = null, currentSlideElement = null;

        // Create and return a new DOM element with specified attributes
        const createElem = (tag, className, textContent, src, alt) => {
            const elem = document.createElement(tag);
            if (className) elem.className = className;
            if (textContent) elem.textContent = textContent;
            if (src) elem.src = src;
            if (alt) elem.alt = alt;
            return elem;
        };

        // Truncate text to a specified maximum length and append '...' if truncated
        const truncateText = (text, maxLength) => text && text.length > maxLength ? text.substr(0, maxLength) + '...' : text;

        // Display error messages to users
        const displayError = (message) => {
            const errorDiv = createElem('div', 'error-message');
            errorDiv.textContent = message;
            document.body.appendChild(errorDiv);
            setTimeout(() => {
                if (errorDiv.parentNode) errorDiv.parentNode.removeChild(errorDiv);
            }, 5000); // Remove after 5 seconds
        };

        // Clean up existing player and timeout
        const cleanup = () => {
            if (player && typeof player.stopVideo === 'function') {
                player.stopVideo();
                player.destroy(); 
                player = null;
                console.log("YouTube player cleaned up.");
            }
            if (slideChangeTimeout) {
                clearTimeout(slideChangeTimeout);
                slideChangeTimeout = null;
                console.log("Slide change timeout cleared.");
            }
        };

        // Shut down the slideshow by cleaning up and resetting variables
        const shutdown = () => {
            isChangingSlide = true;
            cleanup();
            document.getElementById('rightButton').onclick = null;
            document.getElementById('leftButton').onclick = null;
            const container = document.getElementById('slides-container');
            if (container) container.innerHTML = '';
            currentMovie = null;
            lastMovie = null;
            currentMovieIndex = 0;
            movieList = [];
            isHomePageActive = false;
            isChangingSlide = false;
            
            console.log("Slideshow has been completely shutdown");
        };

        // Update the state of navigation buttons based on the current and last movie
        const updateSlideButtons = () => {
            const leftButton = document.getElementById('leftButton');
            leftButton.disabled = !lastMovie || (currentMovie && lastMovie.Id === currentMovie.Id);
            console.log(`Left button disabled: ${leftButton.disabled}`);
        };

        // Check if backdrop and logo images exist for the movie, then create the slide or fetch the next movie
        const checkBackdropAndLogo = movie => {
            Promise.all(['/Images/Backdrop/0', '/Images/Logo'].map(url => 
                fetch(`/Items/${movie.Id}${url}`, { method: 'HEAD' }).then(response => response.ok)
            )).then(([backdropExists, logoExists]) => {
                if (backdropExists && logoExists) {
                    console.log(`Backdrop and logo exist for movie: ${movie.Title}`);
                    createSlideElement(movie, true);
                } else {
                    console.log(`Backdrop or logo missing for movie: ${movie.Title}. Fetching next movie.`);
                    fetchNextMovie();
                }
            }).catch(error => {
                console.error("Error checking backdrop and logo:", error);
                fetchNextMovie();
            });
        };

        // Create and display a new slide element for the given movie
        const createSlideElement = async (movie, hasVideo = false) => {
            cleanup();
            const container = document.getElementById('slides-container');
            const newSlide = createElem('div', 'slide');
            newSlide.appendChild(createElem('img', 'backdrop', null, `/Items/${movie.Id}/Images/Backdrop/0`, 'backdrop'));
            newSlide.appendChild(createElem('img', 'logo', null, `/Items/${movie.Id}/Images/Logo`, 'logo'));

            const textContainer = createElem('div', 'text-container');
            const premiereYear = movie.PremiereDate ? new Date(movie.PremiereDate).getFullYear() : 'Unknown';
            const additionalInfo = movie.Type === 'Series' ? (movie.ChildCount ? `${movie.ChildCount} Season${movie.ChildCount > 1 ? 's' : ''}` : 'Unknown Seasons') : (movie.RunTimeTicks ? `${Math.round(movie.RunTimeTicks / 600000000)} min` : 'Unknown Runtime');

            let loremText = `${premiereYear}   |   ${additionalInfo}`;
            if (movie.CommunityRating) loremText += `   |   <i class=\"star-icon fas fa-star\" aria-hidden="true"></i> ${movie.CommunityRating.toFixed(1)}`;
            if (movie.CriticRating) loremText += `<img src="https://i.imgur.com/iMfwDk7.png" alt="Rotten Tomatoes" style="width: 1.2em; height: 1.2em; padding-left: 0.5em; vertical-align: sub;"> ${movie.CriticRating}%`;
            const loremDiv = createElem('div', 'lorem-ipsum');
            loremDiv.innerHTML = loremText;

            textContainer.appendChild(loremDiv);
            textContainer.appendChild(createElem('div', 'plot', truncateText(movie.Overview, plotMaxLength)));
            newSlide.appendChild(textContainer);

            const overlay = createElem('div', 'clickable-overlay', null, null, 'Movie Details');
            overlay.setAttribute('role', 'button');
            overlay.setAttribute('aria-label', 'View Movie Details');
            overlay.onclick = () => window.top.Emby.Page.showItem(movie.Id);
            overlay.addEventListener('keypress', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    window.top.Emby.Page.showItem(movie.Id);
                }
            });
            newSlide.appendChild(overlay);

            if (useTrailers && movie.RemoteTrailers?.length > 0) {
                const trailerUrl = movie.RemoteTrailers[0].Url;
                let videoId = null;
                try {
                    videoId = new URL(trailerUrl).searchParams.get('v');
                } catch (e) {
                    console.error("Invalid trailer URL:", trailerUrl);
                }

                if (videoId) {
                    let aspectRatio = 16 / 9;
                    try {
                        const response = await fetch('https://noembed.com/embed?url=https://www.youtube.com/watch?v=' + videoId);
                        const data = await response.json();
                        if (data.width && data.height) aspectRatio = data.width / data.height;
                    } catch (e) { 
                        console.error("Error fetching trailer embed data:", e);
                    }

                    const videoContainer = createElem('div', 'video-container', null, null, 'Play Trailer');
                    const videoElement = createElem('div', 'video-player');
                    videoContainer.appendChild(videoElement);
                    newSlide.appendChild(videoContainer);

                    // Initialize YouTube player after ensuring API is ready
                    youTubeAPIReadyPromise.then(YT => {
                        console.log("Initializing YouTube player for video ID:", videoId);
                        player = new YT.Player(videoElement, {
                            height: '100%',
                            width: '100%',
                            videoId: videoId,
                            playerVars: {
                                'autoplay': 1,
                                'controls': 0,
                                'loop': 0,
                                'rel': 0,
                                'modestbranding': 1,
                                'color': 'white',
                                'iv_load_policy': 3,
                                'fs': 0
                            },
                            events: {
                                'onReady': event => {
									console.log("YouTube player ready.");
									event.target.playVideo();
									event.target.setVolume(50);
									
									const videoContainerHeight = videoContainer.clientHeight;
									const calculatedWidth = videoContainerHeight * aspectRatio;
									videoContainer.style.width = `${calculatedWidth}px`;

									const backdropElement = newSlide.querySelector('.backdrop');
									if (backdropElement) {
										// Change multiplier from 0.7 to 0.8 for 80%
										backdropElement.style.width = `calc(100% - ${calculatedWidth * 0.8}px)`;
										
										// Update mask gradient to match new width
										backdropElement.style.webkitMaskImage = backdropElement.style.maskImage = `linear-gradient(to right, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 1) ${65}%, rgba(255, 255, 255, 0) 100%)`;
										
										backdropElement.style.backgroundImage = `url(/Items/${movie.Id}/Images/Backdrop/0)`;
										backdropElement.style.backgroundSize = 'cover';
										backdropElement.style.backgroundPosition = 'center';
									}

									const videoPlayerElement = newSlide.querySelector('.video-player');
									if (videoPlayerElement) {
										videoPlayerElement.style.webkitMaskImage = videoPlayerElement.style.maskImage = `linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 1) 25%)`;
									}

									['clickable-overlay'].forEach(cls => {
										const element = newSlide.querySelector(`.${cls}`);
										if (element) element.style.width = `calc(100% - ${calculatedWidth * 0.8}px)`;
									});
									const playPauseBtn = document.getElementById('playPauseButton');
									if (playPauseBtn) {
										playPauseBtn.style.display = 'inline-block';

										const nav = document.getElementById('navButtons');
										const playIcon = playPauseBtn.querySelector('span.material-icons');
										if (playIcon) {
											playIcon.textContent = 'pause'; // Assume trailer auto-plays
										}
									}
																		
                                },
                                'onStateChange': event => {
                                    if (event.data === YT.PlayerState.ENDED) {
                                        console.log("YouTube video ended. Fetching next movie.");
                                        setTimeout(fetchNextMovie, 100);
                                    }
                                },
                                'onError': event => {
                                    console.error("YouTube Player Error:", event.data);
                                    if (player) {
                                        player.destroy();
                                        player = null;
                                    }

                                    ['backdrop', 'plot', 'lorem-ipsum'].forEach(cls => {
                                        const element = newSlide.querySelector(`.${cls}`);
                                        if (element) element.style.width = '100%';
                                    });
                                    videoContainer.style.width = '0';
                                    startSlideChangeTimer();
                                }
                            }
                        });
                    }).catch(error => {
                        console.error("YouTube Iframe API is not ready or failed to load:", error);
                        startSlideChangeTimer();
                    });
                } else {
                    console.warn("Trailer video ID not found for movie:", movie.Title);
                    startSlideChangeTimer();
                }
            } else {
                startSlideChangeTimer();
            }

            container.appendChild(newSlide);
            void newSlide.offsetWidth;
            newSlide.classList.add('visible');

            const oldSlideElement = currentSlideElement; // Capture the old slide
            if (oldSlideElement) {
                oldSlideElement.classList.remove('visible');
                setTimeout(() => {
                    if (oldSlideElement && oldSlideElement.parentNode) {
                        oldSlideElement.parentNode.removeChild(oldSlideElement);
                        console.log("Old slide removed from DOM.");
                    }
                }, 1300); // Remove after transition
            }
            // Update currentSlideElement
            currentSlideElement = newSlide;

            lastMovie = currentMovie;
            currentMovie = movie;

            updateSlideButtons();
        };

        // Read a custom list of movie IDs from 'list.txt' and update the title
        const readCustomList = () => 
            fetch('list.txt?' + new Date().getTime())
                .then(response => response.ok ? response.text() : null)
                .then(text => {
                    if (!text) return null;
                    const lines = text.split('\n').filter(Boolean);
                    customTitle = lines.shift() || customTitle;
                    // Not Using list titles for now    document.getElementById('titleHeading').textContent = customTitle;
                    return lines.map(line => line.trim().substring(0, 32));
                })
                .catch(error => {
                    console.error("Error reading custom list:", error);
                    return null;
                });

        // Fetch a random movie or the next movie in the custom list
        const fetchRandomMovie = () => {
            if (isChangingSlide) {
                console.log("Slide change already in progress.");
                return;
            }
            isChangingSlide = true;

            if (movieList.length === 0) {
                readCustomList().then(list => {
                    if (list) { 
                        movieList = list; 
                        currentMovieIndex = 0; 
                        console.log("Custom movie list loaded:", movieList);
                    }
                    fetchNextMovie();
                }).catch(error => {
                    console.error("Error loading custom movie list:", error);
                    fetchNextMovie();
                });
            } else {
                fetchNextMovie();
            }
        };

        // Fetch the next movie based on the current list or randomly
        const fetchNextMovie = () => {
            if (currentMovie) lastMovie = currentMovie;

            // Fetch the current user's ID
            const fetchCurrentUserId = () => fetch('/Sessions', {
                headers: { 'Authorization': `MediaBrowser Client="Jellyfin Web", Device="YourDeviceName", DeviceId="YourDeviceId", Version="YourClientVersion", Token="${token}"` }
            })
            .then(response => {
                if (!response.ok) throw new Error(`Network response was not ok: ${response.statusText}`);
                return response.json();
            })
            .then(sessions => {
                const currentSession = sessions.find(session => session.UserId);
                return currentSession ? currentSession.UserId : null;
            })
            .catch(error => {
                console.error("Error fetching current user ID:", error);
                return null;
            });

            fetchCurrentUserId().then(currentUserId => {
                if (!currentUserId) {
                    console.warn("Current user ID not found.");
                    isChangingSlide = false;
                    return;
                }

                const headers = { 'Authorization': `MediaBrowser Client="Jellyfin Web", Device="YourDeviceName", DeviceId="YourDeviceId", Version="YourClientVersion", Token="${token}"` };

                if (movieList.length > 0) {
                    if (currentMovieIndex >= movieList.length) currentMovieIndex = 0; 
                    const movieId = movieList[currentMovieIndex];
                    currentMovieIndex++;

                    fetch(`/Users/${currentUserId}/Items/${movieId}?Fields=Overview,RemoteTrailers,PremiereDate,RunTimeTicks,ChildCount,Title,Type`, { headers })
                        .then(response => {
                            if (!response.ok) throw new Error(`Failed to fetch movie: ${response.statusText}`);
                            return response.json();
                        })
                        .then(movie => {
                            console.log("Fetched movie from custom list:", movie.Title);
                            checkBackdropAndLogo(movie);
                        })
                        .catch(error => {
                            console.error("Error fetching movie from custom list:", error);
                            displayError("Failed to load the next movie. Please try again.");
                            startSlideChangeTimer();
                        })
                        .finally(() => { isChangingSlide = false; });
                } else {
                    const itemTypes = moviesSeriesBoth === 1 ? 'Movie' : (moviesSeriesBoth === 2 ? 'Series' : 'Movie,Series');
                    fetch(`/Users/${currentUserId}/Items?IncludeItemTypes=${itemTypes}&Recursive=true&Limit=1&SortBy=random&Fields=Id,Overview,RemoteTrailers,PremiereDate,RunTimeTicks,ChildCount,Title,Type`, { headers })
                        .then(response => {
                            if (!response.ok) throw new Error(`Failed to fetch random movie: ${response.statusText}`);
                            return response.json();
                        })
                        .then(data => {
                            if (data.Items[0]) {
                                console.log("Fetched random movie:", data.Items[0].Title);
                                checkBackdropAndLogo(data.Items[0]);
                            } else {
                                console.warn("No items found in random fetch.");
                                displayError("No movies found to display.");
                                startSlideChangeTimer();
                            }
                        })
                        .catch(error => {
                            console.error("Error fetching random movie:", error);
                            displayError("Failed to load the next movie. Please try again.");
                            startSlideChangeTimer();
                        })
                        .finally(() => { isChangingSlide = false; });
                }
            });
        };

        // Start a timer to change slides after a specified interval
        const startSlideChangeTimer = () => {
            if (slideChangeTimeout) clearTimeout(slideChangeTimeout);
            slideChangeTimeout = setTimeout(fetchNextMovie, shuffleInterval);
            console.log("Slide change timer started.");
        };

        // Check if the user has navigated away from the homepage and handle slideshow accordingly
        const checkNavigation = () => {
            const newLocation = window.top.location.href;
            
            if (newLocation !== currentLocation) {
                currentLocation = newLocation;
                
                const isHomePage = url => url.endsWith('home.html') || url.endsWith('/web/') || url.endsWith('/web/index.html');
                if (isHomePage(newLocation)) {
                    if (!isHomePageActive) {
                        console.log("Returning to homepage, reactivating slideshow");
                        isHomePageActive = true;
                        cleanup();
                        fetchRandomMovie();
                        attachButtonListeners(); 
                    }
                } else if (isHomePageActive) {
                    console.log("Leaving homepage, shutting down slideshow");
                    shutdown();
                    setTimeout(function(){
                        window.location.href = window.location.href;
                        /* This page reload is strangely critical to ensure
                        we don't double the script vars upon navigating home
                        using Jellyfin's home button. But it makes videos only
                        load on home not navback. Meh, lesser of two evils;
                        True SPA headache... */
                    }, 500);
                }
            }	
        };

        // Attach event listeners to navigation buttons
        const attachButtonListeners = () => {
			const rightButton = document.getElementById('rightButton');
			const leftButton = document.getElementById('leftButton');
			const mediaButton = document.getElementById('mediaButton');
			const playPauseButton = document.getElementById('playPauseButton');
			if (playPauseButton) {
				playPauseButton.onclick = () => {
					if (window.controlYouTubePlayer && typeof window.controlYouTubePlayer.toggle === 'function') {
						window.controlYouTubePlayer.toggle();
					}
				};
				console.log("Play/Pause button listener attached.");
			}

			if (rightButton && leftButton) {
				rightButton.onclick = fetchNextMovie;
				leftButton.onclick = () => {
					if (lastMovie) {
						console.log("Navigating to previous movie:", lastMovie.Title);
						createSlideElement(lastMovie, true);
					}
				};
				console.log("Navigation button listeners attached.");
			}

			// Media info button
			if (mediaButton) {
				mediaButton.onclick = () => {
					if (currentMovie && currentMovie.Id) {
						window.top.Emby.Page.showItem(currentMovie.Id);
					} else {
						console.warn('No current movie to show.');
					}
				};
				console.log("Media info button listener attached.");
			}
			
		};

        // Initialize the slideshow once the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            if (window.innerWidth < 701) useTrailers = false;
            const isHomePage = url => url.includes('/home') || url.endsWith('/web/') || url.endsWith('/web/index.html');
            if (isHomePage(window.top.location.href)) {
                isHomePageActive = true;
                cleanup();
                fetchRandomMovie();
                attachButtonListeners();
                console.log("Slideshow initialized on homepage.");
            }
            navigationInterval = setInterval(checkNavigation, 250);
            console.log("Navigation check interval started.");
        }, { passive: true });

        // Expose controlYouTubePlayer to the global window scope
        window.controlYouTubePlayer = {
            // Toggle play/pause state of the YouTube player
            toggle: function() {
                if (player && typeof player.getPlayerState === 'function') {
                    const state = player.getPlayerState();
                    if (state === YT.PlayerState.PLAYING) {
                        player.pauseVideo();
                        console.log("YouTube player paused.");
                    } else {
                        player.playVideo();
                        console.log("YouTube player playing.");
                    }
                } else {
                    console.warn('YouTube player is not initialized or not available.');
                }
            }
        };
    </script>
</body>
</html>
